\documentclass{article}


% load package with some of the available options - you may not need this!
\usepackage[framed,autolinebreaks,useliterate]{mcode}

% for checklist
\usepackage{enumitem,amssymb}
%\newlist{todolist}{itemize}{2}
%\setlist[todolist]{label=$\square$}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}%
\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}


% something NOT relevant to the usage of the package.
\usepackage{graphicx}
\usepackage{url,textcomp}
\setlength{\parindent}{0pt}
\setlength{\parskip}{18pt}
\title{ECTA Homework 3\\Shape Matching Problem}
\author{\color{red} Djordje Vukcevic, \texttt{djordje.vukcevic@smail.inf.h-brs.de}\\
\color{red}	Supriya Vadiraj,\texttt{supriya.vadiraj @smail.inf.h-brs.de}}

\begin{document}
\maketitle
\section{Assignment Description}
	\begin{enumerate}
		\item Write your own Genetic Algorithm to solve the shape matching problem.
		\item Write your own version of the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) to solve the shape problem.
		\item Compare the performance of the two algorithms on three airfoils (NACA airfoil shapes: 0012, 5522, 9735). Is there a significant difference between a GA and an ES?
	\end{enumerate}

	\begin{itemize}
  	\item Grading Scheme
  		\begin{itemize}
  		\item Genetic Algorithm (20 pts)
  			\begin{itemize}
  			\item Bitstring or Real-Valued (20 pts)
  			\item Bitstring and Real-Valued (+10pts)
  			\end{itemize}
  		\item Evolution Strategies (60 pts)
  		  	\begin{itemize}
  			\item ES with 1/5 rule (30 pts)
  			\item Comparison of Components (5 pts)
  			\item CMA-ES with out evolution paths (30 pts)
  			\item CMA-ES with evolution paths (+10)
  			\end{itemize}
  		\item Comparisons (20 pts)
  		  	\begin{itemize}
  			\item Big beautiful wall of data
  			\end{itemize}
  		\end{itemize}
	\end{itemize}
\newpage


\section{Submission Instructions}
Follow along with the instructions in this PDF, filling in your own code, data, and observations as noted. Your own data should be inserted into the latex code of the PDF and recompiled. All code must be done in MATLAB. The basic structure of the code and fitness function are provided, but all code should be submitted as a separate zipped file in LEA. Relevant sections of code can be inserted directly into this document using the mcode latex package. This package is attached with documentation, and in this document I have provided usage examples.

To be perfectly clear we expect two submissions to LEA:
\begin{enumerate}
	\item 1 PDF (report) -- a modified version of this PDF, with your own code snippets, figures, and responses inserted
	\item 1 ZIP (code and data)   -- a .zip file containing all code use to run experiments (.m files) \textit{and} resulting data as a .mat file
\end{enumerate}

\newpage

\section{Assignment Overview}
\subsection*{Genetic Algorithm}
\begin{itemize}
\item Genetic Algorithms are typically represented by a string, this string could take many forms, such as bitsrings or real-valued numbers. What are the advantages and disadvantages of each encoding in this application? How would you convert each into 32 real-valued numbers? How could you perform crossover and mutation in each? Which do you think would be best?
\begin{itemize}
\item Bitstring : \color{blue}\textit{In Genetic Algorithms all the chromosomes are usually represented as bit strings. This encoding style remains suitable in discrete solution spaces. The reason to consider using bits instead of integers has the necessity to do with the range of data that the pool is created with. Having 32 integers means that crossover can only occur on 32 values that are taken as whole values. But having 1024 bits (32 * 32 bit integers) gives a finer granularity. And adds to the following advantages, by allowing the mutation to be bit flipping and crossover by combining the top part of one integer and the bottom part of another.}
\item \color{black}Real-valued : \color{blue}\textit{If real coding is used, the algorithm uses a convex combination of the two candidates in the mating pool according to some probability pcross to produce two new candidate solutions for the next iteration. And in mutation the algorithm acts on candidate solutions, which are real coded by manipulating the value of the candidates as follows: for each
value place that may be held by a candidate solution, we add the value rand([−5,5]) at  that  value  place  to  the  actual  candidate  solution  with probability pmut, where rand([−5,5]) is a random integer in ([−5,5]). This is to cover a range of mutations ‘about’ the  current candidate  solution  consistent  with  the  place value separation in the decimal system.}
\end{itemize}
\item Implement the encoding you think will perform best and plots its median performance over 20 iterations, using 20,000 evaluations.
\color{red} Plot
\item ***Extra Credit*** Implement both encodings and compare them on
matching task for one of the shapes. Is one significantly better? Can
you explain why? : \color{red} Your text here + a figure w/significance here
\end{itemize}
\subsection*{Comparing Algorithms}
As evolutionary algorithms are based on stochastic processes, they will not perform the same every time. Whenever a comparison between two algorithms or algorithm settings is made, it \emph{must} be a comparison over several runs. Comparisons between runs must take into account the effect of randomness, including significance of results (how likely the result is to be because of chance).
\end{document}